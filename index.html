<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>混沌理論互動探索器</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        h1 {
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1);
            background-size: 200% 200%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: gradientShift 3s ease infinite;
        }

        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .tabs {
            display: flex;
            justify-content: center;
            margin-bottom: 30px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .tab {
            padding: 12px 24px;
            background: rgba(255,255,255,0.1);
            border: none;
            border-radius: 25px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            font-size: 14px;
        }

        .tab:hover {
            background: rgba(255,255,255,0.2);
            transform: translateY(-2px);
        }

        .tab.active {
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }

        .tab-content {
            display: none;
            background: rgba(255,255,255,0.1);
            border-radius: 20px;
            padding: 30px;
            backdrop-filter: blur(15px);
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }

        .tab-content.active {
            display: block;
        }

        .canvas-container {
            position: relative;
            margin: 20px 0;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }

        canvas {
            display: block;
            width: 100%;
            height: 400px;
            background: #000;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-top: 20px;
            align-items: center;
            justify-content: center;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        label {
            font-size: 14px;
            color: #e0e0e0;
            font-weight: 500;
        }

        input[type="range"] {
            width: 120px;
            height: 6px;
            background: rgba(255,255,255,0.2);
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .button {
            padding: 10px 20px;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            border: none;
            border-radius: 25px;
            color: white;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }

        .info-panel {
            background: rgba(0,0,0,0.3);
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
            font-size: 14px;
            line-height: 1.6;
        }

        .value-display {
            font-size: 12px;
            color: #4ecdc4;
            font-weight: bold;
        }

        .butterfly-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
        }

        .butterfly {
            position: absolute;
            width: 20px;
            height: 20px;
            background: radial-gradient(circle, #ff6b6b, #4ecdc4);
            border-radius: 50%;
            animation: float 6s ease-in-out infinite;
            opacity: 0.6;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            50% { transform: translateY(-20px) rotate(180deg); }
        }

        .description {
            text-align: center;
            margin-bottom: 20px;
            font-size: 16px;
            color: #e0e0e0;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            h1 {
                font-size: 2rem;
            }
            
            .tab {
                padding: 8px 16px;
                font-size: 12px;
            }
            
            .tab-content {
                padding: 20px;
            }
            
            .controls {
                gap: 15px;
            }
        }
    </style>
</head>
<body>
    <div class="butterfly-container"></div>
    
    <div class="container">
        <h1>混沌理論互動探索器</h1>
        
        <div class="tabs">
            <button class="tab active" onclick="showTab('lorenz')">洛倫茲吸引子</button>
            <button class="tab" onclick="showTab('mandelbrot')">曼德布洛特集合</button>
            <button class="tab" onclick="showTab('pendulum')">混沌擺</button>
            <button class="tab" onclick="showTab('logistic')">邏輯映射</button>
            <button class="tab" onclick="showTab('julia')">Julia集合</button>
        </div>

        <!-- 洛倫茲吸引子 -->
        <div id="lorenz" class="tab-content active">
            <div class="description">
                探索著名的洛倫茲吸引子 - 蝴蝶效應的數學化身
            </div>
            <div class="canvas-container">
                <canvas id="lorenzCanvas"></canvas>
            </div>
            <div class="controls">
                <div class="control-group">
                    <label>σ (Sigma)</label>
                    <input type="range" id="sigma" min="8" max="12" step="0.1" value="10">
                    <span class="value-display" id="sigmaValue">10</span>
                </div>
                <div class="control-group">
                    <label>ρ (Rho)</label>
                    <input type="range" id="rho" min="20" max="30" step="0.1" value="28">
                    <span class="value-display" id="rhoValue">28</span>
                </div>
                <div class="control-group">
                    <label>β (Beta)</label>
                    <input type="range" id="beta" min="1" max="4" step="0.1" value="2.67">
                    <span class="value-display" id="betaValue">2.67</span>
                </div>
                <div class="control-group">
                    <label>繪製速度</label>
                    <input type="range" id="speed" min="1" max="10" step="1" value="5">
                    <span class="value-display" id="speedValue">5</span>
                </div>
                <div class="control-group">
                    <label>顯示範圍</label>
                    <input type="range" id="scale" min="3" max="15" step="1" value="8">
                    <span class="value-display" id="scaleValue">8</span>
                </div>
                <div class="control-group">
                    <label>軌跡長度</label>
                    <input type="range" id="trailLength" min="500" max="3000" step="100" value="2000">
                    <span class="value-display" id="trailLengthValue">2000</span>
                </div>
                <button class="button" onclick="resetLorenz()">重置</button>
            </div>
            <div class="info-panel">
                <strong>洛倫茲系統：</strong> 由三個耦合的微分方程組成，原本用於模擬大氣對流。微小的初始條件變化會導致截然不同的軌跡，這就是著名的「蝴蝶效應」。調整參數可以看到系統從穩定變為混沌的過程。白色亮點顯示當前位置。
            </div>
        </div>

        <!-- 曼德布洛特集合 -->
        <div id="mandelbrot" class="tab-content">
            <div class="description">
                探索無限複雜的曼德布洛特集合分形
            </div>
            <div class="canvas-container">
                <canvas id="mandelbrotCanvas"></canvas>
            </div>
            <div class="controls">
                <div class="control-group">
                    <label>最大迭代次數</label>
                    <input type="range" id="maxIter" min="50" max="200" step="10" value="100">
                    <span class="value-display" id="maxIterValue">100</span>
                </div>
                <div class="control-group">
                    <label>縮放</label>
                    <input type="range" id="zoom" min="0.5" max="3" step="0.1" value="1">
                    <span class="value-display" id="zoomValue">1</span>
                </div>
                <div class="control-group">
                    <label>中心X</label>
                    <input type="range" id="centerX" min="-2" max="2" step="0.01" value="0">
                    <span class="value-display" id="centerXValue">0</span>
                </div>
                <div class="control-group">
                    <label>中心Y</label>
                    <input type="range" id="centerY" min="-2" max="2" step="0.01" value="0">
                    <span class="value-display" id="centerYValue">0</span>
                </div>
            </div>
            <div class="info-panel">
                <strong>曼德布洛特集合：</strong> 通過迭代複數函數 z = z² + c 生成的分形圖案。黑色區域代表收斂的點，彩色區域顯示發散的速度。無論放大多少倍，邊界都會顯示無限的複雜性。拖動滑桿即可實時探索！
            </div>
        </div>

        <!-- 混沌擺 -->
        <div id="pendulum" class="tab-content">
            <div class="description">
                觀察雙擺的混沌運動
            </div>
            <div class="canvas-container">
                <canvas id="pendulumCanvas"></canvas>
            </div>
            <div class="controls">
                <div class="control-group">
                    <label>重力</label>
                    <input type="range" id="gravity" min="0.5" max="2" step="0.1" value="1">
                    <span class="value-display" id="gravityValue">1</span>
                </div>
                <div class="control-group">
                    <label>阻尼</label>
                    <input type="range" id="damping" min="0.99" max="1" step="0.001" value="0.999">
                    <span class="value-display" id="dampingValue">0.999</span>
                </div>
                <button class="button" onclick="resetPendulum()">重置擺動</button>
            </div>
            <div class="info-panel">
                <strong>雙擺系統：</strong> 兩個連接的擺組成的系統。即使初始條件只有微小差異，軌跡也會迅速分歧。這個簡單的機械系統完美展示了混沌的敏感依賴性。
            </div>
        </div>

        <!-- 邏輯映射 -->
        <div id="logistic" class="tab-content">
            <div class="description">
                探索邏輯映射的分岔圖
            </div>
            <div class="canvas-container">
                <canvas id="logisticCanvas"></canvas>
            </div>
            <div class="controls">
                <div class="control-group">
                    <label>r 參數</label>
                    <input type="range" id="rParam" min="2.5" max="4" step="0.01" value="3.5">
                    <span class="value-display" id="rParamValue">3.5</span>
                </div>
                <div class="control-group">
                    <label>初始值</label>
                    <input type="range" id="x0" min="0.1" max="0.9" step="0.01" value="0.5">
                    <span class="value-display" id="x0Value">0.5</span>
                </div>
                <div class="control-group">
                    <label>顯示範圍</label>
                    <input type="range" id="logisticRange" min="2.5" max="4" step="0.01" value="4">
                    <span class="value-display" id="logisticRangeValue">4</span>
                </div>
            </div>
            <div class="info-panel">
                <strong>邏輯映射：</strong> 簡單的方程式 x_{n+1} = r·x_n·(1-x_n) 展示了從週期性到混沌的轉變。調整 r 參數可以觀察系統如何通過分岔進入混沌狀態。紅線顯示當前 r 值的時間序列。拖動滑桿即可實時觀察！
            </div>
        </div>

        <!-- Julia集合 -->
        <div id="julia" class="tab-content">
            <div class="description">
                探索美麗的Julia集合分形
            </div>
            <div class="canvas-container">
                <canvas id="juliaCanvas"></canvas>
            </div>
            <div class="controls">
                <div class="control-group">
                    <label>實部 (c)</label>
                    <input type="range" id="cReal" min="-2" max="2" step="0.01" value="-0.75">
                    <span class="value-display" id="cRealValue">-0.75</span>
                </div>
                <div class="control-group">
                    <label>虛部 (c)</label>
                    <input type="range" id="cImag" min="-2" max="2" step="0.01" value="0.1">
                    <span class="value-display" id="cImagValue">0.1</span>
                </div>
                <div class="control-group">
                    <label>縮放</label>
                    <input type="range" id="juliaZoom" min="0.5" max="3" step="0.1" value="1">
                    <span class="value-display" id="juliaZoomValue">1</span>
                </div>
            </div>
            <div class="info-panel">
                <strong>Julia集合：</strong> 與曼德布洛特集合相關的分形，通過固定 c 值並改變起始點生成。不同的 c 值會產生截然不同的圖案，展示了參數微小變化對結果的巨大影響。拖動滑桿即可實時看到變化！
            </div>
        </div>
    </div>

    <script>
        // 全局變量
        let animationId;
        let lorenzPoints = [];
        let pendulumState = {
            theta1: Math.PI/2,
            theta2: Math.PI/2,
            omega1: 0,
            omega2: 0,
            trail: []
        };

        // 創建浮動蝴蝶效果
        function createButterflies() {
            const container = document.querySelector('.butterfly-container');
            for (let i = 0; i < 5; i++) {
                const butterfly = document.createElement('div');
                butterfly.className = 'butterfly';
                butterfly.style.left = Math.random() * 100 + '%';
                butterfly.style.top = Math.random() * 100 + '%';
                butterfly.style.animationDelay = Math.random() * 6 + 's';
                butterfly.style.animationDuration = (4 + Math.random() * 4) + 's';
                container.appendChild(butterfly);
            }
        }

        // 標籤切換
        function showTab(tabName) {
            // 隱藏所有內容
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // 顯示選中的標籤
            document.getElementById(tabName).classList.add('active');
            event.target.classList.add('active');
            
            // 停止之前的動畫
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            
            // 初始化對應的可視化
            setTimeout(() => {
                switch(tabName) {
                    case 'lorenz':
                        initLorenz();
                        break;
                    case 'mandelbrot':
                        generateMandelbrot();
                        break;
                    case 'pendulum':
                        initPendulum();
                        break;
                    case 'logistic':
                        drawLogisticMap();
                        break;
                    case 'julia':
                        generateJulia();
                        break;
                }
            }, 100);
        }

        // 洛倫茲吸引子
        function initLorenz() {
            const canvas = document.getElementById('lorenzCanvas');
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            lorenzPoints = [];
            let x = 1, y = 1, z = 1;
            const dt = 0.01;
            let frameCount = 0;
            
            function updateLorenz() {
                const sigma = parseFloat(document.getElementById('sigma').value);
                const rho = parseFloat(document.getElementById('rho').value);
                const beta = parseFloat(document.getElementById('beta').value);
                const speed = parseInt(document.getElementById('speed').value);
                const scale = parseFloat(document.getElementById('scale').value);
                const trailLength = parseInt(document.getElementById('trailLength').value);
                
                // 更新值顯示
                document.getElementById('sigmaValue').textContent = sigma;
                document.getElementById('rhoValue').textContent = rho;
                document.getElementById('betaValue').textContent = beta;
                document.getElementById('speedValue').textContent = speed;
                document.getElementById('scaleValue').textContent = scale;
                document.getElementById('trailLengthValue').textContent = trailLength;
                
                // 根據速度設置計算多少步
                for (let step = 0; step < speed; step++) {
                    // 洛倫茲方程
                    const dx = sigma * (y - x);
                    const dy = x * (rho - z) - y;
                    const dz = x * y - beta * z;
                    
                    x += dx * dt;
                    y += dy * dt;
                    z += dz * dt;
                    
                    lorenzPoints.push({x, y, z});
                }
                
                // 控制軌跡長度
                while (lorenzPoints.length > trailLength) {
                    lorenzPoints.shift();
                }
                
                // 繪製背景淡化效果
                ctx.fillStyle = 'rgba(0, 0, 0, 0.02)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // 繪製軌跡
                for (let i = 1; i < lorenzPoints.length; i++) {
                    const p1 = lorenzPoints[i - 1];
                    const p2 = lorenzPoints[i];
                    
                    // 使用可調整的顯示範圍
                    const screenX1 = canvas.width/2 + p1.x * scale;
                    const screenY1 = canvas.height/2 + p1.y * scale;
                    const screenX2 = canvas.width/2 + p2.x * scale;
                    const screenY2 = canvas.height/2 + p2.y * scale;
                    
                    // 軌跡漸變效果
                    const alpha = Math.pow(i / lorenzPoints.length, 0.5);
                    const hue = (i * 0.5) % 360;
                    
                    ctx.strokeStyle = `hsla(${hue}, 70%, 60%, ${alpha})`;
                    ctx.lineWidth = Math.max(0.5, alpha * 2);
                    ctx.beginPath();
                    ctx.moveTo(screenX1, screenY1);
                    ctx.lineTo(screenX2, screenY2);
                    ctx.stroke();
                }
                
                // 繪製當前點
                if (lorenzPoints.length > 0) {
                    const current = lorenzPoints[lorenzPoints.length - 1];
                    const screenX = canvas.width/2 + current.x * scale;
                    const screenY = canvas.height/2 + current.y * scale;
                    
                    ctx.fillStyle = '#ffffff';
                    ctx.shadowColor = '#ffffff';
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, 3, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
                
                frameCount++;
                animationId = requestAnimationFrame(updateLorenz);
            }
            
            updateLorenz();
        }

        function resetLorenz() {
            lorenzPoints = [];
        }

        // 曼德布洛特集合
        function generateMandelbrot() {
            const canvas = document.getElementById('mandelbrotCanvas');
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            const maxIter = parseInt(document.getElementById('maxIter').value);
            const zoom = parseFloat(document.getElementById('zoom').value);
            const centerX = parseFloat(document.getElementById('centerX').value);
            const centerY = parseFloat(document.getElementById('centerY').value);
            
            // 更新值顯示
            document.getElementById('maxIterValue').textContent = maxIter;
            document.getElementById('zoomValue').textContent = zoom;
            document.getElementById('centerXValue').textContent = centerX;
            document.getElementById('centerYValue').textContent = centerY;
            
            const imageData = ctx.createImageData(canvas.width, canvas.height);
            const data = imageData.data;
            
            for (let px = 0; px < canvas.width; px++) {
                for (let py = 0; py < canvas.height; py++) {
                    const x = centerX + (px - canvas.width/2) * (4/canvas.width) / zoom;
                    const y = centerY + (py - canvas.height/2) * (4/canvas.height) / zoom;
                    
                    let zx = 0, zy = 0;
                    let iter = 0;
                    
                    while (zx*zx + zy*zy < 4 && iter < maxIter) {
                        const temp = zx*zx - zy*zy + x;
                        zy = 2*zx*zy + y;
                        zx = temp;
                        iter++;
                    }
                    
                    const pixelIndex = (py * canvas.width + px) * 4;
                    
                    if (iter === maxIter) {
                        data[pixelIndex] = 0;
                        data[pixelIndex + 1] = 0;
                        data[pixelIndex + 2] = 0;
                    } else {
                        const t = iter / maxIter;
                        data[pixelIndex] = Math.floor(255 * Math.sin(t * Math.PI * 3));
                        data[pixelIndex + 1] = Math.floor(255 * Math.sin(t * Math.PI * 5));
                        data[pixelIndex + 2] = Math.floor(255 * Math.sin(t * Math.PI * 7));
                    }
                    data[pixelIndex + 3] = 255;
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
        }

        // 混沌擺
        function initPendulum() {
            const canvas = document.getElementById('pendulumCanvas');
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            const l1 = 100, l2 = 100, m1 = 10, m2 = 10;
            
            function updatePendulum() {
                const g = parseFloat(document.getElementById('gravity').value);
                const damping = parseFloat(document.getElementById('damping').value);
                
                // 更新值顯示
                document.getElementById('gravityValue').textContent = g;
                document.getElementById('dampingValue').textContent = damping;
                
                // 雙擺方程
                const num1 = -m2 * l1 * pendulumState.omega1 * pendulumState.omega1 * Math.sin(pendulumState.theta1 - pendulumState.theta2) * Math.cos(pendulumState.theta1 - pendulumState.theta2);
                const num2 = -m2 * g * Math.sin(pendulumState.theta2) * Math.cos(pendulumState.theta1 - pendulumState.theta2);
                const num3 = -m2 * l2 * pendulumState.omega2 * pendulumState.omega2 * Math.sin(pendulumState.theta1 - pendulumState.theta2);
                const num4 = -(m1 + m2) * g * Math.sin(pendulumState.theta1);
                const den = l1 * (m1 + m2) - m2 * l1 * Math.cos(pendulumState.theta1 - pendulumState.theta2) * Math.cos(pendulumState.theta1 - pendulumState.theta2);
                
                const alpha1 = (num1 + num2 + num3 + num4) / den;
                
                const num5 = -m2 * l2 * pendulumState.omega2 * pendulumState.omega2 * Math.sin(pendulumState.theta1 - pendulumState.theta2) * Math.cos(pendulumState.theta1 - pendulumState.theta2);
                const num6 = (m1 + m2) * g * Math.sin(pendulumState.theta1) * Math.cos(pendulumState.theta1 - pendulumState.theta2);
                const num7 = (m1 + m2) * l1 * pendulumState.omega1 * pendulumState.omega1 * Math.sin(pendulumState.theta1 - pendulumState.theta2);
                const num8 = -(m1 + m2) * g * Math.sin(pendulumState.theta2);
                const den2 = l2 * (m1 + m2) - m2 * l2 * Math.cos(pendulumState.theta1 - pendulumState.theta2) * Math.cos(pendulumState.theta1 - pendulumState.theta2);
                
                const alpha2 = (num5 + num6 + num7 + num8) / den2;
                
                pendulumState.omega1 += alpha1 * 0.01;
                pendulumState.omega2 += alpha2 * 0.01;
                pendulumState.omega1 *= damping;
                pendulumState.omega2 *= damping;
                pendulumState.theta1 += pendulumState.omega1 * 0.01;
                pendulumState.theta2 += pendulumState.omega2 * 0.01;
                
                // 計算位置
                const x1 = canvas.width/2 + l1 * Math.sin(pendulumState.theta1);
                const y1 = canvas.height/3 + l1 * Math.cos(pendulumState.theta1);
                const x2 = x1 + l2 * Math.sin(pendulumState.theta2);
                const y2 = y1 + l2 * Math.cos(pendulumState.theta2);
                
                // 記錄軌跡
                pendulumState.trail.push({x: x2, y: y2});
                if (pendulumState.trail.length > 200) {
                    pendulumState.trail.shift();
                }
                
                // 繪製
                ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // 繪製軌跡
                ctx.strokeStyle = 'rgba(255, 107, 107, 0.8)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                for (let i = 1; i < pendulumState.trail.length; i++) {
                    const p1 = pendulumState.trail[i - 1];
                    const p2 = pendulumState.trail[i];
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                }
                ctx.stroke();
                
                // 繪製擺
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(canvas.width/2, canvas.height/3);
                ctx.lineTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
                
                // 繪製質量
                ctx.fillStyle = '#4ecdc4';
                ctx.beginPath();
                ctx.arc(x1, y1, 10, 0, 2 * Math.PI);
                ctx.fill();
                
                ctx.fillStyle = '#ff6b6b';
                ctx.beginPath();
                ctx.arc(x2, y2, 10, 0, 2 * Math.PI);
                ctx.fill();
                
                animationId = requestAnimationFrame(updatePendulum);
            }
            
            updatePendulum();
        }

        function resetPendulum() {
            pendulumState = {
                theta1: Math.PI/2 + (Math.random() - 0.5) * 0.1,
                theta2: Math.PI/2 + (Math.random() - 0.5) * 0.1,
                omega1: 0,
                omega2: 0,
                trail: []
            };
        }

        // 邏輯映射
        function drawLogisticMap() {
            const canvas = document.getElementById('logisticCanvas');
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            const rParam = parseFloat(document.getElementById('rParam').value);
            const x0 = parseFloat(document.getElementById('x0').value);
            const rMax = parseFloat(document.getElementById('logisticRange').value);
            
            // 更新值顯示
            document.getElementById('rParamValue').textContent = rParam;
            document.getElementById('x0Value').textContent = x0;
            document.getElementById('logisticRangeValue').textContent = rMax;
            
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 繪製分岔圖
            const rMin = 2.5;
            const iterations = 1000;
            const plotIterations = 100;
            
            for (let i = 0; i < canvas.width; i++) {
                const r = rMin + (rMax - rMin) * i / canvas.width;
                let x = x0;
                
                // 讓系統穩定
                for (let j = 0; j < iterations; j++) {
                    x = r * x * (1 - x);
                }
                
                // 繪製最後的值
                for (let j = 0; j < plotIterations; j++) {
                    x = r * x * (1 - x);
                    const y = canvas.height - x * canvas.height;
                    
                    const hue = (j * 3.6) % 360;
                    ctx.fillStyle = `hsl(${hue}, 70%, 60%)`;
                    ctx.fillRect(i, y, 1, 1);
                }
            }
            
            // 繪製特定 r 值的垂直線
            const rPosition = ((rParam - rMin) / (rMax - rMin)) * canvas.width;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(rPosition, 0);
            ctx.lineTo(rPosition, canvas.height);
            ctx.stroke();
            
            // 繪製特定 r 值的時間序列（在右側）
            ctx.strokeStyle = '#ff6b6b';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            let x = x0;
            const timeSeriesWidth = canvas.width * 0.3;
            const timeSeriesStart = canvas.width * 0.7;
            
            for (let i = 0; i < 100; i++) {
                x = rParam * x * (1 - x);
                const screenX = timeSeriesStart + (timeSeriesWidth / 100) * i;
                const screenY = canvas.height - x * canvas.height;
                
                if (i === 0) {
                    ctx.moveTo(screenX, screenY);
                } else {
                    ctx.lineTo(screenX, screenY);
                }
            }
            ctx.stroke();
        }

        // Julia集合
        function generateJulia() {
            const canvas = document.getElementById('juliaCanvas');
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            const cReal = parseFloat(document.getElementById('cReal').value);
            const cImag = parseFloat(document.getElementById('cImag').value);
            const zoom = parseFloat(document.getElementById('juliaZoom').value);
            
            // 更新值顯示
            document.getElementById('cRealValue').textContent = cReal;
            document.getElementById('cImagValue').textContent = cImag;
            document.getElementById('juliaZoomValue').textContent = zoom;
            
            const imageData = ctx.createImageData(canvas.width, canvas.height);
            const data = imageData.data;
            
            const maxIter = 100;
            
            for (let px = 0; px < canvas.width; px++) {
                for (let py = 0; py < canvas.height; py++) {
                    let zx = (px - canvas.width/2) * (4/canvas.width) / zoom;
                    let zy = (py - canvas.height/2) * (4/canvas.height) / zoom;
                    
                    let iter = 0;
                    
                    while (zx*zx + zy*zy < 4 && iter < maxIter) {
                        const temp = zx*zx - zy*zy + cReal;
                        zy = 2*zx*zy + cImag;
                        zx = temp;
                        iter++;
                    }
                    
                    const pixelIndex = (py * canvas.width + px) * 4;
                    
                    if (iter === maxIter) {
                        data[pixelIndex] = 0;
                        data[pixelIndex + 1] = 0;
                        data[pixelIndex + 2] = 0;
                    } else {
                        const t = iter / maxIter;
                        data[pixelIndex] = Math.floor(255 * Math.sin(t * Math.PI * 2));
                        data[pixelIndex + 1] = Math.floor(255 * Math.sin(t * Math.PI * 4));
                        data[pixelIndex + 2] = Math.floor(255 * Math.sin(t * Math.PI * 6));
                    }
                    data[pixelIndex + 3] = 255;
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
        }

        // 添加控制器事件監聽器
        document.addEventListener('DOMContentLoaded', function() {
            // 洛倫茲控制器
            document.getElementById('sigma').addEventListener('input', function() {
                document.getElementById('sigmaValue').textContent = this.value;
            });
            document.getElementById('rho').addEventListener('input', function() {
                document.getElementById('rhoValue').textContent = this.value;
            });
            document.getElementById('beta').addEventListener('input', function() {
                document.getElementById('betaValue').textContent = this.value;
            });
            document.getElementById('speed').addEventListener('input', function() {
                document.getElementById('speedValue').textContent = this.value;
            });
            document.getElementById('scale').addEventListener('input', function() {
                document.getElementById('scaleValue').textContent = this.value;
            });
            document.getElementById('trailLength').addEventListener('input', function() {
                document.getElementById('trailLengthValue').textContent = this.value;
            });
            
            // 曼德布洛特控制器
            document.getElementById('maxIter').addEventListener('input', function() {
                document.getElementById('maxIterValue').textContent = this.value;
                generateMandelbrot();
            });
            document.getElementById('zoom').addEventListener('input', function() {
                document.getElementById('zoomValue').textContent = this.value;
                generateMandelbrot();
            });
            document.getElementById('centerX').addEventListener('input', function() {
                document.getElementById('centerXValue').textContent = this.value;
                generateMandelbrot();
            });
            document.getElementById('centerY').addEventListener('input', function() {
                document.getElementById('centerYValue').textContent = this.value;
                generateMandelbrot();
            });
            
            // 擺控制器
            document.getElementById('gravity').addEventListener('input', function() {
                document.getElementById('gravityValue').textContent = this.value;
            });
            document.getElementById('damping').addEventListener('input', function() {
                document.getElementById('dampingValue').textContent = this.value;
            });
            
            // 邏輯映射控制器
            document.getElementById('rParam').addEventListener('input', function() {
                document.getElementById('rParamValue').textContent = this.value;
                drawLogisticMap();
            });
            document.getElementById('x0').addEventListener('input', function() {
                document.getElementById('x0Value').textContent = this.value;
                drawLogisticMap();
            });
            document.getElementById('logisticRange').addEventListener('input', function() {
                document.getElementById('logisticRangeValue').textContent = this.value;
                drawLogisticMap();
            });
            
            // Julia集合控制器
            document.getElementById('cReal').addEventListener('input', function() {
                document.getElementById('cRealValue').textContent = this.value;
                generateJulia();
            });
            document.getElementById('cImag').addEventListener('input', function() {
                document.getElementById('cImagValue').textContent = this.value;
                generateJulia();
            });
            document.getElementById('juliaZoom').addEventListener('input', function() {
                document.getElementById('juliaZoomValue').textContent = this.value;
                generateJulia();
            });
            
            // 初始化
            createButterflies();
            initLorenz();
        });
    </script>
</body>
</html>